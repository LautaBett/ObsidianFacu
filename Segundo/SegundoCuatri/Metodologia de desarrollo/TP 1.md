¡Por supuesto! Aquí tienes una propuesta de resolución del Trabajo Práctico, basada en la información de tus notas:

**Trabajo Práctico: Introducción a las Metodologías y a los Modelos de Ciclos de Vida**

**Ejercicio 1**

a)  **Metodología de desarrollo de software:** Es un conjunto de procedimientos y técnicas que definen cómo se va a desarrollar un sistema de software. Indica qué ciclo de vida se utilizará y qué diagramas se generarán en cada etapa del ciclo de vida.

b)  **Modelo de Ciclo de Vida para el desarrollo de software:** Define el orden en el cual las etapas del ciclo de vida van a ser desarrolladas. Es como una receta que indica el orden para tener todo organizado.

c)  **Etapa dentro de un ciclo de vida:** Es una fase específica en el proceso de desarrollo de software, como la captura de requerimientos, análisis, diseño, implementación y testeo.

d)  **Rol que puede cumplir una persona en el desarrollo de software:** Es la función que desempeña una persona dentro del equipo de desarrollo, con responsabilidades específicas.

e)  **Modelo/Diagrama/Artefacto de las características de un sistema de software y sus partes componentes:** Es una representación visual o documental de los diferentes aspectos de un sistema, como diagramas UML (diagramas de clases, diagramas de casos de uso, etc.). Estos diagramas permiten modelar los diferentes aspectos de un sistema.

**Ejercicio 2**

Es importante utilizar una metodología de desarrollo de software porque proporciona una estructura y un orden al proceso de desarrollo. Esto facilita la comunicación entre los miembros del equipo, reduce los riesgos, mejora la calidad del software y aumenta la probabilidad de éxito del proyecto.

**Ejercicio 3**

Los modelos de ciclo de vida más comunes son:

*   **Cascada:** Las etapas se completan secuencialmente. Es ineficiente si hay errores en las primeras etapas, ya que es costoso volver atrás. Es adecuado cuando los requerimientos son estables y bien definidos.
*   **Iterativo:** Divide el problema en subproblemas y aplica un pequeño ciclo de vida en cascada a cada uno (iteraciones). Es una estrategia de "divide y vencerás".
*   **Incremental:** Divide el problema en subproblemas, desarrolla cada subproblema y construye una pequeña porción del sistema final, añadiéndola a lo que ya se tenía.
*   **Iterativo e Incremental:** Combina las características de los modelos iterativo e incremental. Divide el problema en subproblemas, aplica un pequeño ciclo de vida en cascada a cada uno y construye una porción del sistema final relacionada con esa problemática, agregándola a las porciones ya desarrolladas.
*   **Ágiles (Scrum, Lean, Kanban):** Se adaptan a los cambios y a la retroalimentación del cliente.

**Ejercicio 4**

Las etapas de desarrollo de software más comunes son:

*   **Captura de requerimientos:** Se identifican y documentan las necesidades del cliente y los usuarios. Se utilizan casos de uso para representar la funcionalidad del sistema.
*   **Análisis:** Se analizan los requerimientos para comprender el problema y definir una solución.
*   **Diseño:** Se define la arquitectura del sistema y cómo se implementarán los requerimientos. Se encarga de cómo solucionar los requerimientos no funcionales y los funcionales.
*   **Implementación:** Se escribe el código del software.
*   **Testeo:** Se verifica que el software cumple con los requerimientos y funciona correctamente.

**Ejercicio 5**

Los roles más comunes en el desarrollo de software son:

*   **Analista de requerimientos:** Se encarga de capturar y documentar los requerimientos del cliente.
*   **Diseñador:** Define la arquitectura del sistema y cómo se implementarán los requerimientos.
*   **Programador:** Escribe el código del software.
*   **Tester:** Verifica que el software cumple con los requerimientos y funciona correctamente.
*   **Jefe de proyecto/Scrum Master:** Planifica, organiza y supervisa el proyecto.

**Ejercicio 6**

Los factores que influyen a la hora de elegir un modelo de ciclo de vida son:

*   **Complejidad del proyecto:** Proyectos más complejos pueden requerir modelos más flexibles.
*   **Estabilidad de los requerimientos:** Si los requerimientos son inestables, es mejor utilizar un modelo iterativo o ágil.
*   **Conocimiento del dominio:** Si el equipo no conoce bien el dominio, es mejor utilizar un modelo que permita aprender y adaptarse.
*   **Tecnología a utilizar:** Algunas tecnologías se adaptan mejor a ciertos modelos de ciclo de vida.
*   **Riesgos del proyecto:** Se deben considerar los riesgos y elegir un modelo que los mitigue.

**Ejercicio 7**

Para un sistema con dominio conocido, requerimientos estables y tecnología bien conocida, el modelo de ciclo de vida en **cascada** sería una opción adecuada.

**Ejercicio 8**

Para un sistema con dominio desconocido, requerimientos inestables y tecnología nueva, un modelo de ciclo de vida **iterativo e incremental** o un modelo **ágil** sería más apropiado. Estos modelos permiten adaptarse a los cambios, aprender del dominio y experimentar con la tecnología.



¡Por supuesto! Aquí tienes una propuesta de resolución del Trabajo Práctico, basada en la información de tus notas [[Intro a metodologia]], [[Clase 1 20-8-25]] y [[Clase 2 21-8-25]]:

**Trabajo Práctico: Introducción a las Metodologías y a los Modelos de Ciclos de Vida**

**Ejercicio 1**

a)  **Metodología de desarrollo de software:** Define una forma disciplinada para desarrollar software, haciéndolo más predecible y eficiente. Describe el ciclo de vida a utilizar y los artefactos a generar durante el desarrollo. (Fuente: [[Intro a metodologia]])

b)  **Modelo de Ciclo de Vida para el desarrollo de software:** Es una representación abstracta de un proceso que ayuda a ordenar el trabajo a realizar durante la construcción del producto. Indica el orden en que se desarrollarán las etapas del ciclo de vida. (Fuente: [[Intro a metodologia]], [[Clase 1 20-8-25]])

c)  **Etapa dentro de un ciclo de vida:** Es una fase específica en el proceso de desarrollo de software, como la captura de requerimientos, análisis, diseño, implementación y testeo. (Fuente: [[Clase 1 20-8-25]])

d)  **Rol que puede cumplir una persona en el desarrollo de software:** Es la función que desempeña una persona dentro del equipo de desarrollo, con responsabilidades específicas (analista, diseñador, programador, tester, etc.). (Fuente: [[Intro a metodologia]])

e)  **Modelo/Diagrama/Artefacto de las características de un sistema de software y sus partes componentes:** Es cualquier documentación creada, producida, cambiada o utilizada por las personas en el desarrollo del sistema. Ejemplos: diagramas UML (clases, casos de uso, etc.). (Fuente: [[Intro a metodologia]], [[Clase 2 21-8-25]])

**Ejercicio 2**

Es importante utilizar una metodología de desarrollo de software porque proporciona una estructura y un orden al proceso de desarrollo, haciéndolo más predecible y eficiente. Facilita la comunicación entre los miembros del equipo, reduce los riesgos y mejora la calidad del software. (Fuente: [[Intro a metodologia]], [[Clase 1 20-8-25]])

**Ejercicio 3**

Los modelos de ciclo de vida más comunes son:

*   **Cascada:** Las etapas se completan secuencialmente. Es adecuado cuando los requerimientos son estables y bien definidos. (Fuente: [[Clase 1 20-8-25]], [[Intro a metodologia]])
*   **Iterativo:** Divide el problema en subproblemas y aplica un pequeño ciclo de vida en cascada a cada uno (iteraciones). (Fuente: [[Clase 1 20-8-25]], [[Intro a metodologia]])
*   **Incremental:** Divide el problema en subproblemas, desarrolla cada subproblema y construye una pequeña porción del sistema final, añadiéndola a lo que ya se tenía. (Fuente: [[Clase 1 20-8-25]], [[Intro a metodologia]])
*   **Iterativo e Incremental:** Combina las características de los modelos iterativo e incremental. (Fuente: [[Clase 1 20-8-25]], [[Intro a metodologia]])
*   **Ágiles (Scrum, Lean, Kanban):** Se adaptan a los cambios y a la retroalimentación del cliente. (Fuente: [[Clase 1 20-8-25]])

**Ejercicio 4**

Las etapas de desarrollo de software más comunes son:

*   **Captura de requerimientos:** Se identifican y documentan las necesidades del cliente y los usuarios. Se utilizan casos de uso para representar la funcionalidad del sistema. (Fuente: [[Clase 2 21-8-25]], [[Intro a metodologia]])
*   **Análisis:** Se analizan los requerimientos para comprender el problema y definir una solución. (Fuente: [[Intro a metodologia]])
*   **Diseño:** Se define la arquitectura del sistema y cómo se implementarán los requerimientos. (Fuente: [[Intro a metodologia]])
*   **Implementación:** Se escribe el código del software. (Fuente: [[Intro a metodologia]])
*   **Testeo:** Se verifica que el software cumple con los requerimientos y funciona correctamente. (Fuente: [[Intro a metodologia]])

**Ejercicio 5**

Los roles más comunes en el desarrollo de software son:

*   **Analista de sistemas:** Se encarga de capturar y documentar los requerimientos del cliente. (Fuente: [[Intro a metodologia]])
*   **Diseñador:** Define la arquitectura del sistema y cómo se implementarán los requerimientos. (Fuente: [[Intro a metodologia]])
*   **Programador:** Escribe el código del software. (Fuente: [[Intro a metodologia]])
*   **Tester:** Verifica que el software cumple con los requerimientos y funciona correctamente. (Fuente: [[Intro a metodologia]])
*   **Jefe de proyecto/Scrum Master:** Planifica, organiza y supervisa el proyecto. (Fuente: [[Intro a metodologia]])

**Ejercicio 6**

Los factores que influyen a la hora de elegir un modelo de ciclo de vida son:

*   **Complejidad del proyecto:** Proyectos más complejos pueden requerir modelos más flexibles. (Fuente: [[Clase 1 20-8-25]])
*   **Estabilidad de los requerimientos:** Si los requerimientos son inestables, es mejor utilizar un modelo iterativo o ágil. (Fuente: [[Clase 1 20-8-25]])
*   **Conocimiento del dominio:** Si el equipo no conoce bien el dominio, es mejor utilizar un modelo que permita aprender y adaptarse.
*   **Tecnología a utilizar:** Algunas tecnologías se adaptan mejor a ciertos modelos de ciclo de vida.
*   **Riesgos del proyecto:** Se deben considerar los riesgos y elegir un modelo que los mitigue.

**Ejercicio 7**

Para un sistema con dominio conocido, requerimientos estables y tecnología bien conocida, el modelo de ciclo de vida en **cascada** sería una opción adecuada. (Fuente: [[Clase 1 20-8-25]])

**Ejercicio 8**

Para un sistema con dominio desconocido, requerimientos inestables y tecnología nueva, un modelo de ciclo de vida **iterativo e incremental** o un modelo **ágil** sería más apropiado. Estos modelos permiten adaptarse a los cambios, aprender del dominio y experimentar con la tecnología. (Fuente: [[Clase 1 20-8-25]])
